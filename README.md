# NFC-Application
The first design pattern I use is the composite pattern. First of all, composite pattern means single or whole. In other words, composite is used to provide a hierarchy system if there is one. The adaptation according to my project is as follows; if I consider my system here as a tree, from the top to the top, I divide it into departments, corridors and classes. This is my hierarchical structure. On the other hand, there is an additional visit class in my composite pattern. The task of this class allows the security guard to control the class. It checks which class is full, which is empty, or how many students. I, as campussecurity, have created a guard. This security guard is walk around thanks to the visit command. The reason I created this class in composite pattern is that it reaches the entire hierarchical structure. Also, I did not create a client in this pattern. This is because my client is located in main. Everything of all patterns works in my main class and all clients are in this class. Secondly, the design pattern I use is the observer pattern. If the purpose of this pattern changes in the state of a particular object, other objects will benefit from these changes. According to this statement, the second 4 option and the sub-item of the first item in the project are compatible with this pattern. First of all, there are the possibilities of status change and message notification. For example, NFC has an IP-capable lock that sends a message to the security department. This situation carries the purpose of informing about the event that took place in the object in the observer pattern. Looking at item six, there are locks on classrooms and building and there is a security guard who can open these locks. If you want to unlock a class, you must ask the security guard for it. In this case, the observer pattern should notify all other elements of the change in an object. When I look at the second item in the project, I know that there is only one student affairs directorate at the university. In this case I use the Singleton pattern. Because this pattern is a design pattern that guarantees that only one object is created. At the same time, there is only one object for applications. Another pattern I choose is the command pattern. This pattern transforms the operation into an object, allowing the receiving object to complete the operation, and this object contains all the information. When I consider the third and fmyth items in the project, the reason I use this pattern is because it is command and action command. Thanks to this pattern, different departments in this system work without interfering with each other. Another pattern I use is the iterator. This pattern is a way for the collective object to access its elements in order. The purpose of the Iterator pattern is to have two different or more than one different 5 collection. These collections; arraylist, hashmap, stack and linkedlist. It keeps them together and allows us to navigate. My functions that cause this situation are first, next, currentItem and Isdone. At the same time, the place of use of the iterator pattern is the InitializeTag part that I created in the main class. Here, I created the student affairs, the class and the student themselves, respectively. There is an extra campussecurity function in the Iterator pattern. Campussecurity here means security guard. The purpose of this; the guard visits the classes and creates the method that indicates the number of students in these classes. It is also used with the visit method. Finally, I used the facade pattern. The aim here is to remove system complexity. Using this pattern is based on several tasks. First, I have repetitive codes to add tags to the class in the command pattern. At the same time, I need to use the attach method on students. Additionally, I need to create a cmyse in the main class and add students to the cmyse, and I need to forward this to student affairs. I combined all this using the facade pattern and avoided code confusion.
